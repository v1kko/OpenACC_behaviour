{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OpenACC Behaviour This site explores OpenACC pragmas in combination with valid but seldomly used Fortran statements and different compilers. The aim of this site is to document this behaviour for various use cases and compilers, thus providing a knowledge database for those who need it. This site should allow Programmers to save time debugging OpenACC. It can also serve as a basis for compiler providers to \"fix\" or implement other behaviour for certain cases, such that the same OpenACC pragmas execute more similarily for the different compilers. Layout Every chapter describes a problem and how each compiler handles it","title":"Introduction"},{"location":"#openacc-behaviour","text":"This site explores OpenACC pragmas in combination with valid but seldomly used Fortran statements and different compilers. The aim of this site is to document this behaviour for various use cases and compilers, thus providing a knowledge database for those who need it. This site should allow Programmers to save time debugging OpenACC. It can also serve as a basis for compiler providers to \"fix\" or implement other behaviour for certain cases, such that the same OpenACC pragmas execute more similarily for the different compilers.","title":"OpenACC Behaviour"},{"location":"#layout","text":"Every chapter describes a problem and how each compiler handles it","title":"Layout"},{"location":"characters/","text":"Characters in OpenACC Char is not a scalar datatype in Fortran according to spec. Char is an aggregate datatype in Fortran according to spec. This would make a string an aggregate variable No restrictions are places on aggregate variable type. define test to correctly test this","title":"Characters in host routines"},{"location":"characters/#characters-in-openacc","text":"Char is not a scalar datatype in Fortran according to spec. Char is an aggregate datatype in Fortran according to spec. This would make a string an aggregate variable No restrictions are places on aggregate variable type. define test to correctly test this","title":"Characters in OpenACC"},{"location":"copyto_existing_Data/","text":"If a pointer in struct is present on device, does copyin overwrite the pointer with bogus values?","title":"copyto existing Data"},{"location":"pointers_structs/","text":"Type with allocatables Types with allocatables are handled differently by compilers when using OpenACC. OpenACC states: When a data object is copied to device memory, the values are copied exactly. If the data is a data structure that includes a pointer, or is just a pointer, the pointer value copied to device memory will be the host pointer value. If the pointer target object is also allocated in or copied to device memory, the pointer itself needs to be updated with the device address of the target object before dereferencing the pointer in device memory Therefore it is should not be possbile to write a type with allocatables to the gpu in one go (according to the specification). However, Compilers each interpret this differently for different cases, thus we list some differences here: Combined with \"declare create\" Cray: compiler warning, runtime crash Nvidia: no warning, runtime crash Combined with \"enter data\" Cray: runtime crash Nvidia: works Combined with no data/declare statement, only parallel loop Cray: no warning, runtime crash Nvidia: works","title":"Pointers in structs"},{"location":"pointers_structs/#type-with-allocatables","text":"Types with allocatables are handled differently by compilers when using OpenACC. OpenACC states: When a data object is copied to device memory, the values are copied exactly. If the data is a data structure that includes a pointer, or is just a pointer, the pointer value copied to device memory will be the host pointer value. If the pointer target object is also allocated in or copied to device memory, the pointer itself needs to be updated with the device address of the target object before dereferencing the pointer in device memory Therefore it is should not be possbile to write a type with allocatables to the gpu in one go (according to the specification). However, Compilers each interpret this differently for different cases, thus we list some differences here:","title":"Type with allocatables"},{"location":"pointers_structs/#combined-with-declare-create","text":"Cray: compiler warning, runtime crash Nvidia: no warning, runtime crash","title":"Combined with \"declare create\""},{"location":"pointers_structs/#combined-with-enter-data","text":"Cray: runtime crash Nvidia: works","title":"Combined with \"enter data\""},{"location":"pointers_structs/#combined-with-no-datadeclare-statement-only-parallel-loop","text":"Cray: no warning, runtime crash Nvidia: works","title":"Combined with no data/declare statement, only parallel loop"}]}